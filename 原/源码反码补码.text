大家都直到，在计算机中主要是以补码的形式存储，那么为什么二进制数在原码、反码、补码中选择以补码的形式存储呢？

一、为什么不以原码形式存储？
  首先，原码是站在用户角度的，是原始的二进制！

求原码：
    1.用户的数字分为正负数，需要有一位存储符号

    2.最高位为符号位：0为正，1为负

    3.左边是高位，右边是低位

由原码的计算方式可以发现源码存储会引发2个问题：
0有两个存储方式
         我们以char型（占1字节，8位）为例（下同）：

                            +0：    0000 0000

                             -0：    1000 0000

          不难发现+0和-0的原码是不一样的，而在计算过程中，+0和-0是没有任何区别的。

    2. 正数和负数相加，结果不正确（计算机只会加）

         1 - 1 =1 + （-1）

          1：  0000 0001

        -1：  1000 0001

                 1000 0010  =  -2

       很显然1-1=0，而用原码进行计算得出的结果却相差甚远！

二、为什么不以反码形式存储？
 既然原码不适合作为计算机的存储方式，人们在解决这个问题的过程中又提出了反码的概念

求反码：
求原码
符号为不变，其他位取反
注意：正数原码、反码一样!

接下来我们检验一下1 - 1：
        1：    0000 0001

     -  1：   1111 1110

                 1111 1111 ->1000 000(转换为原码，因为原码是站在用户角度的) = -0

       不难可能出反码已经解决的正负数相加结果不正确的问题

   然后我们再检验+0、-0
              +0  0000 0000

               -0  1111 1111

        由此看出，反码并没有解决0有两种形式的问题

反码存储会引发1个问题：

0有两个存储方式
三、补码存储
  在反码的基础上，人们有提出了补码的概念

求补码：
   补码为其反码+1
注意：正数的原码、反码、补码都一样！

 

接下来我们对补码存储进行验证：

 

    +0： 0000 0000

     -0： 原码：  1000 0000

             反码：  1111 1111

             补码：1 0000 0000（char占1字节八位，最高位丢弃）= 0000 0000

 可以看出补码解决了+0 -0不一样的问题

 

    +1： 0000 0001

     -1： 1111 1111 

          1 0000 0000（最高位丢弃）=0000 0000 = 0

 那么补码也解决了正负数相加结果不正确的问题！ 

 

总结：
     补码是在原码的基础上为了适应计算机运算一步一步完善而来，原码和反码存储都有一定的弊端，因此计算机采用补码存储！
————————————————
版权声明：本文为CSDN博主「CC_YXK」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。
原文链接：https://blog.csdn.net/qq_41727218/article/details/79521759